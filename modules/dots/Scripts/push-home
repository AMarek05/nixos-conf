#!/usr/bin/env bash
set -e

REPO="/home/adam/sys";
cd "$REPO" || exit 1

git pull --rebase

# Find the SHA of the *oldest* commit made today.
# We list in reverse (oldest-to-newest) and take the first one.
OLDEST_TODAY_SHA=$(git rev-list --reverse --since="00:00" HEAD | head -n 1)

# If the string is empty, no commits were made today.
if [ -z "$OLDEST_TODAY_SHA" ]; then
    echo "No commits today. Nothing to squash."
    exit 0
fi

# Try to find the parent of that oldest commit.
# We use '|| true' so 'set -e' doesn't kill the script if the
# 'git rev-parse' fails (which it will on a root commit).
# '2>/dev/null' silences the "fatal: bad revision" error.

if git rev-parse "${OLDEST_TODAY_SHA}^" >/dev/null 2>&1; then
    # 2. If the check succeeds (non-root commit), set BASE_SHA to the parent's hash.
    # The command is run again, this time capturing the output.
    BASE_SHA=$(git rev-parse "${OLDEST_TODAY_SHA}^")
else
    # 3. If the check fails (root commit), explicitly set BASE_SHA to an empty string.
    BASE_SHA=""
fi

COMMIT_MSG="Daily commit: $(date +%F)"

if [ -z "$BASE_SHA" ]; then

    echo "Root commit was created today. Amending root to squash all changes..."

    # Reset to the root commit, staging all changes from subsequent commits
    git reset --soft "$OLDEST_TODAY_SHA"

    # Amend the root commit, replacing it with a new squashed commit
    git commit --amend -m "$COMMIT_MSG"

else
    # --- This is the Normal Case ---
    # We found a valid parent. Reset to it.

    echo "Squashing commits back to base $BASE_SHA..."

    # Reset to the commit *before* today's work
    git reset --soft "$BASE_SHA"

    # Create a new commit with all the staged changes
    git commit -m "$COMMIT_MSG"
fi

echo "Pushing squashed commit..."
git push --force-with-lease

